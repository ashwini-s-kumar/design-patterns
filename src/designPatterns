Creational Patterns: These patterns deal with object creation mechanisms,
trying to create objects in a manner suitable to the situation. The five creational patterns are:

1. Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

2. Builder: Separates the construction of a complex object from its representation, allowing the same construction process to create various representations.

3. Factory Method: Defines an interface for creating objects, but lets subclasses decide which classes to instantiate.

4. Prototype: Creates new objects by cloning existing ones.

5. Singleton: Ensures a class has only one instance, and provides a global point of access to it.

Structural Patterns: These patterns deal with object composition,
such as classes or objects being composed into larger structures. The seven structural patterns are:

1. Adapter: Allows classes with incompatible interfaces to work together by wrapping an interface around one of the objects.

2. Bridge: Separates an object’s interface from its implementation, so they can vary independently.

3. Composite: Allows objects to be composed into tree structures to represent part-whole hierarchies.

4. Decorator: Dynamically adds behavior to an object without changing its interface.

5. Facade: Provides a unified interface to a set of interfaces in a subsystem, simplifying their usage.

6. Flyweight: Shares objects to support large numbers of fine-grained objects efficiently.

7. Proxy: Provides a placeholder for another object to control its access.

Behavioral Patterns: These patterns deal with communication between objects and how they operate together.
The eleven behavioral patterns are:

1. Chain of Responsibility: Passes a request through a chain of objects to find the one that can handle it.

2. Command: Encapsulates a request as an object, allowing it to be treated as a parameter, stored, and executed later.

3. Interpreter: Defines a language’s grammar, and creates a representation of the grammar for the language.

4. Iterator: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

5. Mediator: Defines simplified communication between objects in a system.

6. Memento: Allows the state of an object to be saved and restored later without violating encapsulation.

7. Observer: Notifies objects of changes in another object’s state.

8. State: Allows an object to change its behavior when its internal state changes.

9. Strategy: Defines a family of algorithms, encapsulating each one, and making them interchangeable.

10. Template Method: Defines the skeleton of an algorithm in a method, allowing its subclasses to redefine certain steps of the algorithm without changing its structure.

11. Visitor: Separates an algorithm from an object’s structure by moving the algorithm into a separate object.